name: Build/Push Image to AWS ECR
on:

  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/**'
      - 'Jenkins/**'      
      - 'README.md'

  workflow_dispatch:
    inputs:
      version_bump:
        description: "Version bump type ('none' for tag 'latest' only)"
        required: true
        type: choice
        options:
          - none
          - patch
          - minor
          - major
        default: "patch"
      push_on_test_failure:
        description: "Push image even if tests fail?"
        required: true
        type: choice
        options:
          - "no"
          - "yes"
        default: "yes"
      image_name:
        description: "Docker image name"
        required: true
        type: string
        default: "api"
      ecr_region:
        description: "AWS region for ECR repository"
        required: true
        type: choice
        options:
          - us-east-1
          - us-east-2
          - us-west-1
          - us-west-2
          - ca-central-1
        default: us-east-1
      ecr_repository_name:
        description: "ECR repository name"
        required: true
        type: string
        default: "nodejs-nyan-app"
env:
  DOCKERFILE_PATH: '.'
jobs:

  setup:
    name: Setup Configuration
    runs-on: ubuntu-latest
    outputs:
      version_bump: ${{ steps.config.outputs.version_bump }}
      push_on_test_failure: ${{ steps.config.outputs.push_on_test_failure }}
      image_name: ${{ steps.config.outputs.image_name }}
      ecr_region: ${{ steps.config.outputs.ecr_region }}
      ecr_repository_name: ${{ steps.config.outputs.ecr_repository_name }}
    steps:
      - name: Set Configuration
        id: config
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION_BUMP="${{ inputs.version_bump }}"
            PUSH_ON_FAILURE="${{ inputs.push_on_test_failure }}"
            IMAGE_NAME="${{ inputs.image_name }}"
            ECR_REGION="${{ inputs.ecr_region }}"
            ECR_REPO_NAME="${{ inputs.ecr_repository_name }}"
          else
            VERSION_BUMP="patch"
            PUSH_ON_FAILURE="no"
            IMAGE_NAME="api"
            ECR_REGION="us-east-1"
            ECR_REPO_NAME="nodejs-nyan-app"
          fi
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          else
          fi
      - name: Verify Configuration Outputs
        run: |

  lint:
    name: Lint Test
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: npm install
      - name: Run ESLint
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          npm run lint 2>/dev/null || echo " Lint not configured"

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: npm install
      - name: Run Unit Tests
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          npm test 2>/dev/null || echo " Tests not configured"

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: npm install
      - name: Run Integration Tests
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          npm run test:integration 2>/dev/null || echo " Integration tests not configured"

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: npm install
      - name: Run npm audit
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: npm audit --audit-level=moderate || true

  dockerfile-lint:
    name: Dockerfile Lint
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Lint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: ${{ env.DOCKERFILE_PATH }}/Dockerfile
          failure-threshold: warning

  dependency-check:
    name: Dependency Validation
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Validate package.json
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          [ -f "package.json" ] || { echo " package.json not found"; exit 1; }
          jq empty package.json 2>/dev/null || { echo " Invalid JSON"; exit 1; }
      - name: Check for outdated dependencies
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          npm install
          npm outdated || echo " Outdated dependencies"
      - name: Check for duplicate dependencies
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          npm dedupe --dry-run || echo " Duplicate dependencies"

  license-check:
    name: License Compliance
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: npm install
      - name: Install license-checker
        run: npm install -g license-checker
      - name: Check licenses (Summary)
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: license-checker --summary
      - name: Check licenses (Detailed)
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          license-checker --json > licenses.json
          cat licenses.json
      - name: Check for prohibited licenses
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          PROHIBITED="GPL|AGPL|LGPL"
          if license-checker --json | jq -r '.[] | .licenses' | grep -iE "$PROHIBITED"; then
            license-checker --json | jq -r 'to_entries[] | select(.value.licenses | test("GPL|AGPL|LGPL"; "i")) | "\(.key): \(.value.licenses)"'
          fi
      - name: Generate license report
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: license-checker --csv > license-report.csv
      - name: Upload license report
        uses: actions/upload-artifact@v4
        with:
          name: license-report
          path: |
            ${{ env.DOCKERFILE_PATH }}/licenses.json
            ${{ env.DOCKERFILE_PATH }}/license-report.csv
          retention-days: 30

  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [setup, lint, unit-tests, integration-tests, security, dockerfile-lint, dependency-check, license-check]
    if: ${{ always() }}
    environment: dev
    permissions:
      id-token: write
      contents: write
      packages: write
    outputs:
      image_tag: ${{ steps.version.outputs.tag }}
      image_name: ${{ steps.version.outputs.full_image_name }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}
      ecr_repository: ${{ steps.check-repo.outputs.full_repo_name }}
      local_image_name: ${{ needs.setup.outputs.image_name }}
    steps:
      - name: Debug Configuration
        run: |
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Configure AWS Credentials (OIDC)
        id: aws-credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/Role-GitHubActionsECRPushToRepo-api
          role-session-name: GitHubActions-ECR-Push-${{ github.run_id }}
          aws-region: ${{ needs.setup.outputs.ecr_region || 'us-east-1' }}
          mask-aws-account-id: false
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Check if ECR Repository Exists
        id: check-repo
        run: |
          BASE_REPO="${{ needs.setup.outputs.ecr_repository_name }}"
          IMAGE_NAME="${{ needs.setup.outputs.image_name }}"
          FULL_REPO_NAME="$BASE_REPO/$IMAGE_NAME"
          if aws ecr describe-repositories --repository-names $FULL_REPO_NAME --region ${{ needs.setup.outputs.ecr_region }} 2>/dev/null; then
          else
          fi
      - name: Create ECR Repository
        if: steps.check-repo.outputs.exists == 'false'
        run: |
          FULL_REPO_NAME="${{ steps.check-repo.outputs.full_repo_name }}"
          aws ecr create-repository \
            --repository-name $FULL_REPO_NAME \
            --region ${{ needs.setup.outputs.ecr_region }} \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256 \
            --tags Key=ManagedBy,Value=GitHub-Actions Key=Project,Value=EKS-cluster Key=Environment,Value=dev Key=ImageName,Value=${{ needs.setup.outputs.image_name }}
      - name: Set ECR Lifecycle Policy
        continue-on-error: true
        run: |
          FULL_REPO_NAME="${{ steps.check-repo.outputs.full_repo_name }}"
          cat > /tmp/lifecycle-policy.json << 'EOF'
          {
            "rules": [{
              "rulePriority": 1,
              "description": "Keep only last 5 images",
              "selection": {
                "tagStatus": "any",
                "countType": "imageCountMoreThan",
                "countNumber": 5
              },
              "action": {"type": "expire"}
            }]
          }
          EOF
          if aws ecr put-lifecycle-policy \
            --repository-name $FULL_REPO_NAME \
            --region ${{ needs.setup.outputs.ecr_region }} \
            --lifecycle-policy-text file:///tmp/lifecycle-policy.json 2>/dev/null; then
          else
          fi
      - name: Get latest version from ECR
        id: get-version
        if: needs.setup.outputs.version_bump != 'none'
        run: |
          FULL_REPO_NAME="${{ steps.check-repo.outputs.full_repo_name }}"
          TAGS=$(aws ecr describe-images \
            --repository-name $FULL_REPO_NAME \
            --region ${{ needs.setup.outputs.ecr_region }} \
            --query 'imageDetails[*].imageTags[*]' \
            --output text 2>/dev/null | tr '\t' '\n' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed 's/^v//' | sort -V | tail -1)
          LATEST_VERSION="${TAGS:-0.0.0}"
      - name: Bump version
        id: bump
        if: needs.setup.outputs.version_bump != 'none'
        run: |
          LATEST_VERSION="${{ steps.get-version.outputs.latest_version }}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
          case "${{ needs.setup.outputs.version_bump }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
      - name: Set version tag and full image name
        id: version
        run: |
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          FULL_REPO_NAME="${{ steps.check-repo.outputs.full_repo_name }}"
          FULL_IMAGE_NAME="$ECR_REGISTRY/$FULL_REPO_NAME"
          VERSION_TAG="${{ needs.setup.outputs.version_bump == 'none' && 'latest' || steps.bump.outputs.new_version }}"
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Check Test Results
        run: |
          if [ "${{ needs.setup.outputs.push_on_test_failure }}" = "yes" ]; then
          fi
      - name: Build Docker Image
        working-directory: ${{ env.DOCKERFILE_PATH }}
        run: |
          VERSION_TAG="${{ steps.version.outputs.tag }}"
          docker build -t ${{ needs.setup.outputs.image_name }}:$VERSION_TAG .
      - name: Save Docker Image
        run: |
          docker save ${{ needs.setup.outputs.image_name }}:${{ steps.version.outputs.tag }} | gzip > /tmp/docker-image.tar.gz
      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image.tar.gz
          retention-days: 1

  test-image-vulnerabilities:
    name: Scan Image Vulnerabilities
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

  test-image-health:
    name: Test Image Health
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Test Health Endpoint
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          docker run -d --name health-test \
            -p 3000:3000 \
            -e DBUSER=testuser \
            -e DB=testdb \
            -e DBPASS=testpass \
            -e DBHOST=localhost \
            -e DBPORT=3306 \
            $IMAGE_URI
          sleep 5
          if curl -f http://localhost:3000/health; then
          else
            docker logs health-test
            exit 1
          fi
          docker stop health-test
          docker rm health-test

  test-image-startup:
    name: Test Image Startup
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Test Container Startup
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          docker run -d --name startup-test \
            -p 3001:3000 \
            -e DBUSER=testuser \
            -e DB=testdb \
            -e DBPASS=testpass \
            -e DBHOST=localhost \
            -e DBPORT=3306 \
            $IMAGE_URI
          sleep 5
          if docker ps | grep startup-test; then
          else
            docker logs startup-test
            exit 1
          fi
          docker stop startup-test
          docker rm startup-test

  test-image-size:
    name: Test Image Size
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Check Image Size
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          IMAGE_SIZE=$(docker image inspect $IMAGE_URI --format='{{.Size}}')
          IMAGE_SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
          if [ $IMAGE_SIZE_MB -gt 500 ]; then
          else
          fi

  test-image-ports:
    name: Test Port Exposure
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Check Exposed Ports
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          EXPOSED_PORTS=$(docker image inspect $IMAGE_URI --format='{{json .Config.ExposedPorts}}')
          if echo "$EXPOSED_PORTS" | grep -q "3000"; then
          else
            exit 1
          fi

  test-image-env-vars:
    name: Test Environment Variables
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Test with Missing Environment Variables
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          docker run -d --name env-test -p 3002:3000 $IMAGE_URI || true
          sleep 3
          if docker ps -a | grep env-test | grep -q "Exited"; then
            docker logs env-test
          else
          fi
          docker stop env-test 2>/dev/null || true
          docker rm env-test 2>/dev/null || true

  test-image-security:
    name: Test Security (Non-root User)
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Check User Permissions
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          USER=$(docker image inspect $IMAGE_URI --format='{{.Config.User}}')
          if [ -z "$USER" ] || [ "$USER" = "root" ] || [ "$USER" = "0" ]; then
          else
          fi

  test-image-shutdown:
    name: Test Graceful Shutdown
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ needs.setup.outputs.push_on_test_failure == 'yes' }}
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Test SIGTERM Handling
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          docker run -d --name shutdown-test \
            -p 3003:3000 \
            -e DBUSER=testuser \
            -e DB=testdb \
            -e DBPASS=testpass \
            -e DBHOST=localhost \
            -e DBPORT=3306 \
            $IMAGE_URI
          sleep 3
          START_TIME=$(date +%s)
          docker stop -t 10 shutdown-test
          END_TIME=$(date +%s)
          SHUTDOWN_TIME=$((END_TIME - START_TIME))
          if [ $SHUTDOWN_TIME -lt 10 ]; then
          else
          fi
          docker rm shutdown-test

  test-image-layers:
    name: Analyze Image Layers
    runs-on: ubuntu-latest
    needs: [build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: true
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Analyze Image Layers
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          docker history $IMAGE_URI
          LAYER_COUNT=$(docker history $IMAGE_URI --format "{{.ID}}" | wc -l)
          if [ $LAYER_COUNT -gt 20 ]; then
          else
          fi

  push-image:
    name: Push Docker Image to ECR
    runs-on: ubuntu-latest
    needs: [
      setup,
      build-image, 
      test-image-vulnerabilities,
      test-image-health, 
      test-image-startup, 
      test-image-size,
      test-image-ports,
      test-image-env-vars,
      test-image-security,
      test-image-shutdown,
      test-image-layers
    ]
    if: ${{ always() && needs.build-image.result == 'success' && (needs.setup.outputs.push_on_test_failure == 'yes' || (needs.test-image-health.result == 'success' && needs.test-image-startup.result == 'success' && needs.test-image-size.result == 'success')) }}
    environment: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - name: Load Docker Image
        run: |
          docker load < /tmp/docker-image.tar.gz
      - name: Configure AWS Credentials (OIDC)
        id: aws-credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/Role-GitHubActionsECRPushToRepo-api
          role-session-name: GitHubActions-ECR-Push-${{ github.run_id }}
          aws-region: ${{ needs.setup.outputs.ecr_region || 'us-east-1' }}
          mask-aws-account-id: false
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Tag Images for ECR
        run: |
          VERSION_TAG="${{ needs.build-image.outputs.image_tag }}"
          LOCAL_IMAGE="${{ needs.build-image.outputs.local_image_name }}"
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          ECR_REPO="${{ needs.build-image.outputs.ecr_repository }}"
          docker tag $LOCAL_IMAGE:$VERSION_TAG $ECR_REGISTRY/$ECR_REPO:$VERSION_TAG
          docker tag $LOCAL_IMAGE:$VERSION_TAG $ECR_REGISTRY/$ECR_REPO:latest
          docker tag $LOCAL_IMAGE:$VERSION_TAG $ECR_REGISTRY/$ECR_REPO:${{ github.sha }}
      - name: Check Image Test Results
        run: |
          if [ "${{ needs.setup.outputs.push_on_test_failure }}" = "yes" ]; then
          else
          fi
      - name: Push Docker Image to ECR
        run: |
          VERSION_TAG="${{ needs.build-image.outputs.image_tag }}"
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          ECR_REPO="${{ needs.build-image.outputs.ecr_repository }}"
          docker push $ECR_REGISTRY/$ECR_REPO:$VERSION_TAG
          docker push $ECR_REGISTRY/$ECR_REPO:latest
          docker push $ECR_REGISTRY/$ECR_REPO:${{ github.sha }}
      - name: Get Image Details from ECR
        id: image-details
        run: |
          ECR_REPO="${{ needs.build-image.outputs.ecr_repository }}"
          VERSION_TAG="${{ needs.build-image.outputs.image_tag }}"
          IMAGE_DIGEST=$(aws ecr describe-images \
            --repository-name $ECR_REPO \
            --image-ids imageTag=$VERSION_TAG \
            --region ${{ needs.setup.outputs.ecr_region }} \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          IMAGE_SIZE=$(aws ecr describe-images \
            --repository-name $ECR_REPO \
            --image-ids imageTag=$VERSION_TAG \
            --region ${{ needs.setup.outputs.ecr_region }} \
            --query 'imageDetails[0].imageSizeInBytes' \
            --output text)
          IMAGE_SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
          REPO_URI=$(aws ecr describe-repositories \
            --repository-names $ECR_REPO \
            --region ${{ needs.setup.outputs.ecr_region }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
      - name: Output Summary
        if: success()
        run: |
      - name: Output Failure Summary
        if: failure()
        run: |

  cleanup-artifacts:
    name: Cleanup Temporary Artifacts
    runs-on: ubuntu-latest
    needs: [push-image]
    if: ${{ always() && needs.push-image.result != 'skipped' }}
    steps:
      - name: Delete Docker Image Artifact
        uses: geekyeggo/delete-artifact@v5
        with:
          name: docker-image
          failOnError: false
      - name: Cleanup Summary
        run: |
